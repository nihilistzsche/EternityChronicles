//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.2-rc1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.2-rc1 Dependency/Parser/ECX.g 2020-12-29 13:13:24

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.2-rc1")]
[System.CLSCompliant(false)]
public partial class ECXLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int AND=4;
	public const int CLASS=5;
	public const int DOT=6;
	public const int EQ=7;
	public const int GT=8;
	public const int GTE=9;
	public const int ID=10;
	public const int ID_LETTER=11;
	public const int ID_START_LETTER=12;
	public const int INT=13;
	public const int LD=14;
	public const int LPAREN=15;
	public const int LT=16;
	public const int LTE=17;
	public const int NEQ=18;
	public const int NL=19;
	public const int OPT=20;
	public const int OR=21;
	public const int RPAREN=22;
	public const int VER=23;
	public const int WS=24;
	public const int XOR=25;

	// delegates
	// delegators

	public ECXLexer()
	{
		OnCreated();
	}

	public ECXLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public ECXLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "Dependency/Parser/ECX.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 1);
		TraceIn("LPAREN", 1);
		try
		{
			int _type = LPAREN;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:77:7: ( '(' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:77:9: '('
			{
			DebugLocation(77, 9);
			Match('('); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LPAREN", 1);
			LeaveRule("LPAREN", 1);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 2);
		TraceIn("RPAREN", 2);
		try
		{
			int _type = RPAREN;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:78:7: ( ')' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:78:9: ')'
			{
			DebugLocation(78, 9);
			Match(')'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RPAREN", 2);
			LeaveRule("RPAREN", 2);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_AND();
	partial void LeaveRule_AND();

	// $ANTLR start "AND"
	[GrammarRule("AND")]
	private void mAND()
	{
		EnterRule_AND();
		EnterRule("AND", 3);
		TraceIn("AND", 3);
		try
		{
			int _type = AND;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:81:4: ( '&&' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:81:6: '&&'
			{
			DebugLocation(81, 6);
			Match("&&"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AND", 3);
			LeaveRule("AND", 3);
			LeaveRule_AND();
		}
	}
	// $ANTLR end "AND"

	partial void EnterRule_OR();
	partial void LeaveRule_OR();

	// $ANTLR start "OR"
	[GrammarRule("OR")]
	private void mOR()
	{
		EnterRule_OR();
		EnterRule("OR", 4);
		TraceIn("OR", 4);
		try
		{
			int _type = OR;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:82:3: ( '||' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:82:5: '||'
			{
			DebugLocation(82, 5);
			Match("||"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OR", 4);
			LeaveRule("OR", 4);
			LeaveRule_OR();
		}
	}
	// $ANTLR end "OR"

	partial void EnterRule_XOR();
	partial void LeaveRule_XOR();

	// $ANTLR start "XOR"
	[GrammarRule("XOR")]
	private void mXOR()
	{
		EnterRule_XOR();
		EnterRule("XOR", 5);
		TraceIn("XOR", 5);
		try
		{
			int _type = XOR;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:83:4: ( '^^' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:83:6: '^^'
			{
			DebugLocation(83, 6);
			Match("^^"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("XOR", 5);
			LeaveRule("XOR", 5);
			LeaveRule_XOR();
		}
	}
	// $ANTLR end "XOR"

	partial void EnterRule_OPT();
	partial void LeaveRule_OPT();

	// $ANTLR start "OPT"
	[GrammarRule("OPT")]
	private void mOPT()
	{
		EnterRule_OPT();
		EnterRule("OPT", 6);
		TraceIn("OPT", 6);
		try
		{
			int _type = OPT;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:84:4: ( '??' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:84:6: '??'
			{
			DebugLocation(84, 6);
			Match("??"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OPT", 6);
			LeaveRule("OPT", 6);
			LeaveRule_OPT();
		}
	}
	// $ANTLR end "OPT"

	partial void EnterRule_EQ();
	partial void LeaveRule_EQ();

	// $ANTLR start "EQ"
	[GrammarRule("EQ")]
	private void mEQ()
	{
		EnterRule_EQ();
		EnterRule("EQ", 7);
		TraceIn("EQ", 7);
		try
		{
			int _type = EQ;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:87:3: ( '==' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:87:5: '=='
			{
			DebugLocation(87, 5);
			Match("=="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EQ", 7);
			LeaveRule("EQ", 7);
			LeaveRule_EQ();
		}
	}
	// $ANTLR end "EQ"

	partial void EnterRule_NEQ();
	partial void LeaveRule_NEQ();

	// $ANTLR start "NEQ"
	[GrammarRule("NEQ")]
	private void mNEQ()
	{
		EnterRule_NEQ();
		EnterRule("NEQ", 8);
		TraceIn("NEQ", 8);
		try
		{
			int _type = NEQ;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:88:4: ( '!=' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:88:6: '!='
			{
			DebugLocation(88, 6);
			Match("!="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NEQ", 8);
			LeaveRule("NEQ", 8);
			LeaveRule_NEQ();
		}
	}
	// $ANTLR end "NEQ"

	partial void EnterRule_LTE();
	partial void LeaveRule_LTE();

	// $ANTLR start "LTE"
	[GrammarRule("LTE")]
	private void mLTE()
	{
		EnterRule_LTE();
		EnterRule("LTE", 9);
		TraceIn("LTE", 9);
		try
		{
			int _type = LTE;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:89:4: ( '<=' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:89:6: '<='
			{
			DebugLocation(89, 6);
			Match("<="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LTE", 9);
			LeaveRule("LTE", 9);
			LeaveRule_LTE();
		}
	}
	// $ANTLR end "LTE"

	partial void EnterRule_LT();
	partial void LeaveRule_LT();

	// $ANTLR start "LT"
	[GrammarRule("LT")]
	private void mLT()
	{
		EnterRule_LT();
		EnterRule("LT", 10);
		TraceIn("LT", 10);
		try
		{
			int _type = LT;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:90:3: ( '<<' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:90:5: '<<'
			{
			DebugLocation(90, 5);
			Match("<<"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LT", 10);
			LeaveRule("LT", 10);
			LeaveRule_LT();
		}
	}
	// $ANTLR end "LT"

	partial void EnterRule_GTE();
	partial void LeaveRule_GTE();

	// $ANTLR start "GTE"
	[GrammarRule("GTE")]
	private void mGTE()
	{
		EnterRule_GTE();
		EnterRule("GTE", 11);
		TraceIn("GTE", 11);
		try
		{
			int _type = GTE;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:91:4: ( '>=' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:91:6: '>='
			{
			DebugLocation(91, 6);
			Match(">="); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GTE", 11);
			LeaveRule("GTE", 11);
			LeaveRule_GTE();
		}
	}
	// $ANTLR end "GTE"

	partial void EnterRule_GT();
	partial void LeaveRule_GT();

	// $ANTLR start "GT"
	[GrammarRule("GT")]
	private void mGT()
	{
		EnterRule_GT();
		EnterRule("GT", 12);
		TraceIn("GT", 12);
		try
		{
			int _type = GT;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:92:3: ( '>>' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:92:5: '>>'
			{
			DebugLocation(92, 5);
			Match(">>"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GT", 12);
			LeaveRule("GT", 12);
			LeaveRule_GT();
		}
	}
	// $ANTLR end "GT"

	partial void EnterRule_LD();
	partial void LeaveRule_LD();

	// $ANTLR start "LD"
	[GrammarRule("LD")]
	private void mLD()
	{
		EnterRule_LD();
		EnterRule("LD", 13);
		TraceIn("LD", 13);
		try
		{
			int _type = LD;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:93:3: ( '##' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:93:5: '##'
			{
			DebugLocation(93, 5);
			Match("##"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LD", 13);
			LeaveRule("LD", 13);
			LeaveRule_LD();
		}
	}
	// $ANTLR end "LD"

	partial void EnterRule_NL();
	partial void LeaveRule_NL();

	// $ANTLR start "NL"
	[GrammarRule("NL")]
	private void mNL()
	{
		EnterRule_NL();
		EnterRule("NL", 14);
		TraceIn("NL", 14);
		try
		{
			int _type = NL;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:94:3: ( '!#' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:94:5: '!#'
			{
			DebugLocation(94, 5);
			Match("!#"); 


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NL", 14);
			LeaveRule("NL", 14);
			LeaveRule_NL();
		}
	}
	// $ANTLR end "NL"

	partial void EnterRule_INT();
	partial void LeaveRule_INT();

	// $ANTLR start "INT"
	[GrammarRule("INT")]
	private void mINT()
	{
		EnterRule_INT();
		EnterRule("INT", 15);
		TraceIn("INT", 15);
		try
		{
			// Dependency/Parser/ECX.g:99:4: ( ( '0' .. '9' )+ )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:99:6: ( '0' .. '9' )+
			{
			DebugLocation(99, 6);
			// Dependency/Parser/ECX.g:99:6: ( '0' .. '9' )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if (((LA1_1>='0' && LA1_1<='9')))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// Dependency/Parser/ECX.g:
					{
					DebugLocation(99, 6);
					input.Consume();


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

		}
		finally
		{
			TraceOut("INT", 15);
			LeaveRule("INT", 15);
			LeaveRule_INT();
		}
	}
	// $ANTLR end "INT"

	partial void EnterRule_VER();
	partial void LeaveRule_VER();

	// $ANTLR start "VER"
	[GrammarRule("VER")]
	private void mVER()
	{
		EnterRule_VER();
		EnterRule("VER", 16);
		TraceIn("VER", 16);
		try
		{
			int _type = VER;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:100:4: ( INT ( DOT INT ( DOT INT ( DOT INT )? )? )? )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:100:6: INT ( DOT INT ( DOT INT ( DOT INT )? )? )?
			{
			DebugLocation(100, 6);
			mINT(); 
			DebugLocation(100, 10);
			// Dependency/Parser/ECX.g:100:10: ( DOT INT ( DOT INT ( DOT INT )? )? )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1=='.'))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Dependency/Parser/ECX.g:100:11: DOT INT ( DOT INT ( DOT INT )? )?
				{
				DebugLocation(100, 11);
				mDOT(); 
				DebugLocation(100, 15);
				mINT(); 
				DebugLocation(100, 19);
				// Dependency/Parser/ECX.g:100:19: ( DOT INT ( DOT INT )? )?
				int alt3=2;
				try { DebugEnterSubRule(3);
				try { DebugEnterDecision(3, false);
				int LA3_1 = input.LA(1);

				if ((LA3_1=='.'))
				{
					alt3 = 1;
				}
				} finally { DebugExitDecision(3); }
				switch (alt3)
				{
				case 1:
					DebugEnterAlt(1);
					// Dependency/Parser/ECX.g:100:20: DOT INT ( DOT INT )?
					{
					DebugLocation(100, 20);
					mDOT(); 
					DebugLocation(100, 24);
					mINT(); 
					DebugLocation(100, 28);
					// Dependency/Parser/ECX.g:100:28: ( DOT INT )?
					int alt2=2;
					try { DebugEnterSubRule(2);
					try { DebugEnterDecision(2, false);
					int LA2_1 = input.LA(1);

					if ((LA2_1=='.'))
					{
						alt2 = 1;
					}
					} finally { DebugExitDecision(2); }
					switch (alt2)
					{
					case 1:
						DebugEnterAlt(1);
						// Dependency/Parser/ECX.g:100:29: DOT INT
						{
						DebugLocation(100, 29);
						mDOT(); 
						DebugLocation(100, 33);
						mINT(); 

						}
						break;

					}
					} finally { DebugExitSubRule(2); }


					}
					break;

				}
				} finally { DebugExitSubRule(3); }


				}
				break;

			}
			} finally { DebugExitSubRule(4); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("VER", 16);
			LeaveRule("VER", 16);
			LeaveRule_VER();
		}
	}
	// $ANTLR end "VER"

	partial void EnterRule_DOT();
	partial void LeaveRule_DOT();

	// $ANTLR start "DOT"
	[GrammarRule("DOT")]
	private void mDOT()
	{
		EnterRule_DOT();
		EnterRule("DOT", 17);
		TraceIn("DOT", 17);
		try
		{
			// Dependency/Parser/ECX.g:105:4: ( '.' )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:105:6: '.'
			{
			DebugLocation(105, 6);
			Match('.'); 

			}

		}
		finally
		{
			TraceOut("DOT", 17);
			LeaveRule("DOT", 17);
			LeaveRule_DOT();
		}
	}
	// $ANTLR end "DOT"

	partial void EnterRule_ID_START_LETTER();
	partial void LeaveRule_ID_START_LETTER();

	// $ANTLR start "ID_START_LETTER"
	[GrammarRule("ID_START_LETTER")]
	private void mID_START_LETTER()
	{
		EnterRule_ID_START_LETTER();
		EnterRule("ID_START_LETTER", 18);
		TraceIn("ID_START_LETTER", 18);
		try
		{
			// Dependency/Parser/ECX.g:110:2: ( ( 'a' .. 'z' ) | ( 'A' .. 'Z' ) | ( '_' ) )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:
			{
			DebugLocation(110, 2);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("ID_START_LETTER", 18);
			LeaveRule("ID_START_LETTER", 18);
			LeaveRule_ID_START_LETTER();
		}
	}
	// $ANTLR end "ID_START_LETTER"

	partial void EnterRule_ID_LETTER();
	partial void LeaveRule_ID_LETTER();

	// $ANTLR start "ID_LETTER"
	[GrammarRule("ID_LETTER")]
	private void mID_LETTER()
	{
		EnterRule_ID_LETTER();
		EnterRule("ID_LETTER", 19);
		TraceIn("ID_LETTER", 19);
		try
		{
			// Dependency/Parser/ECX.g:117:2: ( ID_START_LETTER | ( '0' .. '9' ) | ( '-' ) )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:
			{
			DebugLocation(117, 2);
			if (input.LA(1)=='-'||(input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("ID_LETTER", 19);
			LeaveRule("ID_LETTER", 19);
			LeaveRule_ID_LETTER();
		}
	}
	// $ANTLR end "ID_LETTER"

	partial void EnterRule_ID();
	partial void LeaveRule_ID();

	// $ANTLR start "ID"
	[GrammarRule("ID")]
	private void mID()
	{
		EnterRule_ID();
		EnterRule("ID", 20);
		TraceIn("ID", 20);
		try
		{
			// Dependency/Parser/ECX.g:123:3: ( ID_START_LETTER ( ID_LETTER )* )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:123:5: ID_START_LETTER ( ID_LETTER )*
			{
			DebugLocation(123, 5);
			mID_START_LETTER(); 
			DebugLocation(123, 21);
			// Dependency/Parser/ECX.g:123:21: ( ID_LETTER )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1=='-'||(LA5_1>='0' && LA5_1<='9')||(LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z')))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// Dependency/Parser/ECX.g:
					{
					DebugLocation(123, 21);
					input.Consume();


					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

		}
		finally
		{
			TraceOut("ID", 20);
			LeaveRule("ID", 20);
			LeaveRule_ID();
		}
	}
	// $ANTLR end "ID"

	partial void EnterRule_CLASS();
	partial void LeaveRule_CLASS();

	// $ANTLR start "CLASS"
	[GrammarRule("CLASS")]
	private void mCLASS()
	{
		EnterRule_CLASS();
		EnterRule("CLASS", 21);
		TraceIn("CLASS", 21);
		try
		{
			int _type = CLASS;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:125:6: ( ID ( DOT ID )* )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:125:8: ID ( DOT ID )*
			{
			DebugLocation(125, 8);
			mID(); 
			DebugLocation(125, 11);
			// Dependency/Parser/ECX.g:125:11: ( DOT ID )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1=='.'))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// Dependency/Parser/ECX.g:125:13: DOT ID
					{
					DebugLocation(125, 13);
					mDOT(); 
					DebugLocation(125, 17);
					mID(); 

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CLASS", 21);
			LeaveRule("CLASS", 21);
			LeaveRule_CLASS();
		}
	}
	// $ANTLR end "CLASS"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 22);
		TraceIn("WS", 22);
		try
		{
			int _type = WS;
			int _channel = DefaultTokenChannel;
			// Dependency/Parser/ECX.g:128:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:128:9: ( ' ' | '\\t' | '\\r' | '\\n' )
			{
			DebugLocation(128, 9);
			if ((input.LA(1)>='\t' && input.LA(1)<='\n')||input.LA(1)=='\r'||input.LA(1)==' ')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(132, 11);
			_channel=Hidden;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WS", 22);
			LeaveRule("WS", 22);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	public override void mTokens()
	{
		// Dependency/Parser/ECX.g:1:8: ( LPAREN | RPAREN | AND | OR | XOR | OPT | EQ | NEQ | LTE | LT | GTE | GT | LD | NL | VER | CLASS | WS )
		int alt7=17;
		try { DebugEnterDecision(7, false);
		switch (input.LA(1))
		{
		case '(':
			{
			alt7 = 1;
			}
			break;
		case ')':
			{
			alt7 = 2;
			}
			break;
		case '&':
			{
			alt7 = 3;
			}
			break;
		case '|':
			{
			alt7 = 4;
			}
			break;
		case '^':
			{
			alt7 = 5;
			}
			break;
		case '?':
			{
			alt7 = 6;
			}
			break;
		case '=':
			{
			alt7 = 7;
			}
			break;
		case '!':
			{
			int LA7_2 = input.LA(2);

			if ((LA7_2=='='))
			{
				alt7 = 8;
			}
			else if ((LA7_2=='#'))
			{
				alt7 = 14;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 7, 8, input, 2);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			}
			break;
		case '<':
			{
			int LA7_2 = input.LA(2);

			if ((LA7_2=='='))
			{
				alt7 = 9;
			}
			else if ((LA7_2=='<'))
			{
				alt7 = 10;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 7, 9, input, 2);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			}
			break;
		case '>':
			{
			int LA7_2 = input.LA(2);

			if ((LA7_2=='='))
			{
				alt7 = 11;
			}
			else if ((LA7_2=='>'))
			{
				alt7 = 12;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 7, 10, input, 2);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			}
			break;
		case '#':
			{
			alt7 = 13;
			}
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			{
			alt7 = 15;
			}
			break;
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z':
			{
			alt7 = 16;
			}
			break;
		case '\t':
		case '\n':
		case '\r':
		case ' ':
			{
			alt7 = 17;
			}
			break;
		default:
			{
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
		}

		} finally { DebugExitDecision(7); }
		switch (alt7)
		{
		case 1:
			DebugEnterAlt(1);
			// Dependency/Parser/ECX.g:1:10: LPAREN
			{
			DebugLocation(1, 10);
			mLPAREN(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// Dependency/Parser/ECX.g:1:17: RPAREN
			{
			DebugLocation(1, 17);
			mRPAREN(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// Dependency/Parser/ECX.g:1:24: AND
			{
			DebugLocation(1, 24);
			mAND(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// Dependency/Parser/ECX.g:1:28: OR
			{
			DebugLocation(1, 28);
			mOR(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// Dependency/Parser/ECX.g:1:31: XOR
			{
			DebugLocation(1, 31);
			mXOR(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// Dependency/Parser/ECX.g:1:35: OPT
			{
			DebugLocation(1, 35);
			mOPT(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// Dependency/Parser/ECX.g:1:39: EQ
			{
			DebugLocation(1, 39);
			mEQ(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// Dependency/Parser/ECX.g:1:42: NEQ
			{
			DebugLocation(1, 42);
			mNEQ(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// Dependency/Parser/ECX.g:1:46: LTE
			{
			DebugLocation(1, 46);
			mLTE(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// Dependency/Parser/ECX.g:1:50: LT
			{
			DebugLocation(1, 50);
			mLT(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// Dependency/Parser/ECX.g:1:53: GTE
			{
			DebugLocation(1, 53);
			mGTE(); 

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// Dependency/Parser/ECX.g:1:57: GT
			{
			DebugLocation(1, 57);
			mGT(); 

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// Dependency/Parser/ECX.g:1:60: LD
			{
			DebugLocation(1, 60);
			mLD(); 

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// Dependency/Parser/ECX.g:1:63: NL
			{
			DebugLocation(1, 63);
			mNL(); 

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// Dependency/Parser/ECX.g:1:66: VER
			{
			DebugLocation(1, 66);
			mVER(); 

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// Dependency/Parser/ECX.g:1:70: CLASS
			{
			DebugLocation(1, 70);
			mCLASS(); 

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// Dependency/Parser/ECX.g:1:76: WS
			{
			DebugLocation(1, 76);
			mWS(); 

			}
			break;

		}

	}


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

	#endregion

}
