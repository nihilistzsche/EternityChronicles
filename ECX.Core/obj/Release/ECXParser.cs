//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.2-rc1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.2-rc1 Dependency\\Parser\\ECX.g 2020-12-28 09:16:18

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


	//
// ANTLR Generated Files.
//
// Author:
//     Michael Tindal <urilith@gentoo.org>
//
// Copyright (C) 2005 Michael Tindal and the individuals listed on
// the ChangeLog entries.
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using ECX.Core.Dependency;

	// Class does not need CLSCompliant attribute
	#pragma warning disable 3021


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace  ECX.Core.Dependency.Parser 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.2-rc1")]
[System.CLSCompliant(false)]
public partial class ECXParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "CLASS", "DOT", "EQ", "GT", "GTE", "ID", "ID_LETTER", "ID_START_LETTER", "INT", "LD", "LPAREN", "LT", "LTE", "NEQ", "NL", "OPT", "OR", "RPAREN", "VER", "WS", "XOR"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int CLASS=5;
	public const int DOT=6;
	public const int EQ=7;
	public const int GT=8;
	public const int GTE=9;
	public const int ID=10;
	public const int ID_LETTER=11;
	public const int ID_START_LETTER=12;
	public const int INT=13;
	public const int LD=14;
	public const int LPAREN=15;
	public const int LT=16;
	public const int LTE=17;
	public const int NEQ=18;
	public const int NL=19;
	public const int OPT=20;
	public const int OR=21;
	public const int RPAREN=22;
	public const int VER=23;
	public const int WS=24;
	public const int XOR=25;

	public ECXParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public ECXParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return ECXParser.tokenNames; } }
	public override string GrammarFileName { get { return "Dependency\\Parser\\ECX.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_expr();
	partial void LeaveRule_expr();
	// $ANTLR start "expr"
	// Dependency\\Parser\\ECX.g:136:8: public expr returns [DepNode result] : zexpr EOF ;
	[GrammarRule("expr")]
	public DepNode expr()
	{
		EnterRule_expr();
		EnterRule("expr", 1);
		TraceIn("expr", 1);
		DepNode result = default(DepNode);


		DepNode zexpr1 = default(DepNode);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(136, 1);
		try
		{
			// Dependency\\Parser\\ECX.g:137:2: ( zexpr EOF )
			DebugEnterAlt(1);
			// Dependency\\Parser\\ECX.g:137:4: zexpr EOF
			{
			DebugLocation(137, 4);
			PushFollow(Follow._zexpr_in_expr416);
			zexpr1=zexpr();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(137, 10);
			Match(input,EOF,Follow._EOF_in_expr418); if (state.failed) return result;
			DebugLocation(137, 14);
			if (state.backtracking == 0)
			{
				 result = zexpr1; 
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expr", 1);
			LeaveRule("expr", 1);
			LeaveRule_expr();
		}
		DebugLocation(138, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return result;

	}
	// $ANTLR end "expr"

	partial void EnterRule_cexpr();
	partial void LeaveRule_cexpr();
	// $ANTLR start "cexpr"
	// Dependency\\Parser\\ECX.g:140:1: cexpr returns [DepNode result] : LPAREN ( AND | OR | XOR | OPT ) ( zexpr )+ RPAREN ;
	[GrammarRule("cexpr")]
	private DepNode cexpr()
	{
		EnterRule_cexpr();
		EnterRule("cexpr", 2);
		TraceIn("cexpr", 2);
		DepNode result = default(DepNode);


		DepNode zexpr2 = default(DepNode);

		DepOps op = DepOps.Null; List<DepNode> zn = new List<DepNode>(); 
		try { DebugEnterRule(GrammarFileName, "cexpr");
		DebugLocation(140, 1);
		try
		{
			// Dependency\\Parser\\ECX.g:142:2: ( LPAREN ( AND | OR | XOR | OPT ) ( zexpr )+ RPAREN )
			DebugEnterAlt(1);
			// Dependency\\Parser\\ECX.g:142:4: LPAREN ( AND | OR | XOR | OPT ) ( zexpr )+ RPAREN
			{
			DebugLocation(142, 4);
			Match(input,LPAREN,Follow._LPAREN_in_cexpr441); if (state.failed) return result;
			DebugLocation(142, 11);
			// Dependency\\Parser\\ECX.g:142:11: ( AND | OR | XOR | OPT )
			int alt1=4;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case AND:
				{
				alt1 = 1;
				}
				break;
			case OR:
				{
				alt1 = 2;
				}
				break;
			case XOR:
				{
				alt1 = 3;
				}
				break;
			case OPT:
				{
				alt1 = 4;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// Dependency\\Parser\\ECX.g:142:12: AND
				{
				DebugLocation(142, 12);
				Match(input,AND,Follow._AND_in_cexpr444); if (state.failed) return result;
				DebugLocation(142, 16);
				if (state.backtracking == 0)
				{
					 op = DepOps.And; 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Dependency\\Parser\\ECX.g:142:39: OR
				{
				DebugLocation(142, 39);
				Match(input,OR,Follow._OR_in_cexpr450); if (state.failed) return result;
				DebugLocation(142, 42);
				if (state.backtracking == 0)
				{
					 op = DepOps.Or;
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Dependency\\Parser\\ECX.g:142:63: XOR
				{
				DebugLocation(142, 63);
				Match(input,XOR,Follow._XOR_in_cexpr456); if (state.failed) return result;
				DebugLocation(142, 67);
				if (state.backtracking == 0)
				{
					 op = DepOps.Xor; 
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Dependency\\Parser\\ECX.g:142:90: OPT
				{
				DebugLocation(142, 90);
				Match(input,OPT,Follow._OPT_in_cexpr462); if (state.failed) return result;
				DebugLocation(142, 94);
				if (state.backtracking == 0)
				{
					 op = DepOps.Opt; 
				}

				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(142, 116);
			// Dependency\\Parser\\ECX.g:142:116: ( zexpr )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==LPAREN))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// Dependency\\Parser\\ECX.g:142:117: zexpr
					{
					DebugLocation(142, 117);
					PushFollow(Follow._zexpr_in_cexpr468);
					zexpr2=zexpr();
					PopFollow();
					if (state.failed) return result;
					DebugLocation(142, 123);
					if (state.backtracking == 0)
					{
						 zn.Add(zexpr2); 
					}

					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					if (state.backtracking>0) {state.failed=true; return result;}
					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(142, 152);
			Match(input,RPAREN,Follow._RPAREN_in_cexpr474); if (state.failed) return result;
			DebugLocation(142, 159);
			if (state.backtracking == 0)
			{

						var dn = new DepNode(op);
						zn.ForEach(node => dn.AddChild(node));
						result = dn;
					
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("cexpr", 2);
			LeaveRule("cexpr", 2);
			LeaveRule_cexpr();
		}
		DebugLocation(147, 1);
		} finally { DebugExitRule(GrammarFileName, "cexpr"); }
		return result;

	}
	// $ANTLR end "cexpr"

	partial void EnterRule_zexpr();
	partial void LeaveRule_zexpr();
	// $ANTLR start "zexpr"
	// Dependency\\Parser\\ECX.g:150:1: zexpr returns [DepNode result] : ( cexpr | oexpr );
	[GrammarRule("zexpr")]
	private DepNode zexpr()
	{
		EnterRule_zexpr();
		EnterRule("zexpr", 3);
		TraceIn("zexpr", 3);
		DepNode result = default(DepNode);


		DepNode cexpr3 = default(DepNode);
		DepNode oexpr4 = default(DepNode);

		try { DebugEnterRule(GrammarFileName, "zexpr");
		DebugLocation(150, 1);
		try
		{
			// Dependency\\Parser\\ECX.g:151:2: ( cexpr | oexpr )
			int alt3=2;
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==LPAREN))
			{
				int LA3_2 = input.LA(2);

				if ((LA3_2==AND||(LA3_2>=OPT && LA3_2<=OR)||LA3_2==XOR))
				{
					alt3 = 1;
				}
				else if (((LA3_2>=EQ && LA3_2<=GTE)||LA3_2==LD||(LA3_2>=LT && LA3_2<=NL)))
				{
					alt3 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 3, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return result;}
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// Dependency\\Parser\\ECX.g:151:4: cexpr
				{
				DebugLocation(151, 4);
				PushFollow(Follow._cexpr_in_zexpr492);
				cexpr3=cexpr();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(151, 10);
				if (state.backtracking == 0)
				{
					 result = cexpr3; 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Dependency\\Parser\\ECX.g:151:41: oexpr
				{
				DebugLocation(151, 41);
				PushFollow(Follow._oexpr_in_zexpr498);
				oexpr4=oexpr();
				PopFollow();
				if (state.failed) return result;
				DebugLocation(151, 47);
				if (state.backtracking == 0)
				{
					 result = oexpr4; 
				}

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("zexpr", 3);
			LeaveRule("zexpr", 3);
			LeaveRule_zexpr();
		}
		DebugLocation(152, 1);
		} finally { DebugExitRule(GrammarFileName, "zexpr"); }
		return result;

	}
	// $ANTLR end "zexpr"

	partial void EnterRule_oexpr();
	partial void LeaveRule_oexpr();
	// $ANTLR start "oexpr"
	// Dependency\\Parser\\ECX.g:154:1: oexpr returns [DepNode result] : LPAREN ( EQ | NEQ | LTE | LT | GTE | GT | LD | NL ) iexpr RPAREN ;
	[GrammarRule("oexpr")]
	private DepNode oexpr()
	{
		EnterRule_oexpr();
		EnterRule("oexpr", 4);
		TraceIn("oexpr", 4);
		DepNode result = default(DepNode);


		DepConstraint iexpr5 = default(DepConstraint);

		 DepOps op = DepOps.Null; 
		try { DebugEnterRule(GrammarFileName, "oexpr");
		DebugLocation(154, 1);
		try
		{
			// Dependency\\Parser\\ECX.g:156:2: ( LPAREN ( EQ | NEQ | LTE | LT | GTE | GT | LD | NL ) iexpr RPAREN )
			DebugEnterAlt(1);
			// Dependency\\Parser\\ECX.g:156:4: LPAREN ( EQ | NEQ | LTE | LT | GTE | GT | LD | NL ) iexpr RPAREN
			{
			DebugLocation(156, 4);
			Match(input,LPAREN,Follow._LPAREN_in_oexpr521); if (state.failed) return result;
			DebugLocation(156, 11);
			// Dependency\\Parser\\ECX.g:156:11: ( EQ | NEQ | LTE | LT | GTE | GT | LD | NL )
			int alt4=8;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			switch (input.LA(1))
			{
			case EQ:
				{
				alt4 = 1;
				}
				break;
			case NEQ:
				{
				alt4 = 2;
				}
				break;
			case LTE:
				{
				alt4 = 3;
				}
				break;
			case LT:
				{
				alt4 = 4;
				}
				break;
			case GTE:
				{
				alt4 = 5;
				}
				break;
			case GT:
				{
				alt4 = 6;
				}
				break;
			case LD:
				{
				alt4 = 7;
				}
				break;
			case NL:
				{
				alt4 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return result;}
					NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// Dependency\\Parser\\ECX.g:156:12: EQ
				{
				DebugLocation(156, 12);
				Match(input,EQ,Follow._EQ_in_oexpr524); if (state.failed) return result;
				DebugLocation(156, 15);
				if (state.backtracking == 0)
				{
					 op = DepOps.Equal; 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// Dependency\\Parser\\ECX.g:156:40: NEQ
				{
				DebugLocation(156, 40);
				Match(input,NEQ,Follow._NEQ_in_oexpr530); if (state.failed) return result;
				DebugLocation(156, 44);
				if (state.backtracking == 0)
				{
					 op = DepOps.NotEqual; 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// Dependency\\Parser\\ECX.g:156:72: LTE
				{
				DebugLocation(156, 72);
				Match(input,LTE,Follow._LTE_in_oexpr536); if (state.failed) return result;
				DebugLocation(156, 76);
				if (state.backtracking == 0)
				{
					 op = DepOps.LessThanEqual; 
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// Dependency\\Parser\\ECX.g:156:109: LT
				{
				DebugLocation(156, 109);
				Match(input,LT,Follow._LT_in_oexpr542); if (state.failed) return result;
				DebugLocation(156, 112);
				if (state.backtracking == 0)
				{
					 op = DepOps.LessThan; 
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// Dependency\\Parser\\ECX.g:157:4: GTE
				{
				DebugLocation(157, 4);
				Match(input,GTE,Follow._GTE_in_oexpr549); if (state.failed) return result;
				DebugLocation(157, 8);
				if (state.backtracking == 0)
				{
					 op = DepOps.GreaterThanEqual; 
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// Dependency\\Parser\\ECX.g:157:44: GT
				{
				DebugLocation(157, 44);
				Match(input,GT,Follow._GT_in_oexpr555); if (state.failed) return result;
				DebugLocation(157, 47);
				if (state.backtracking == 0)
				{
					 op = DepOps.GreaterThan; 
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// Dependency\\Parser\\ECX.g:157:78: LD
				{
				DebugLocation(157, 78);
				Match(input,LD,Follow._LD_in_oexpr561); if (state.failed) return result;
				DebugLocation(157, 81);
				if (state.backtracking == 0)
				{
					 op = DepOps.Loaded; 
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// Dependency\\Parser\\ECX.g:157:107: NL
				{
				DebugLocation(157, 107);
				Match(input,NL,Follow._NL_in_oexpr567); if (state.failed) return result;
				DebugLocation(157, 110);
				if (state.backtracking == 0)
				{
					 op = DepOps.NotLoaded; 
				}

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(158, 2);
			PushFollow(Follow._iexpr_in_oexpr573);
			iexpr5=iexpr();
			PopFollow();
			if (state.failed) return result;
			DebugLocation(158, 8);
			Match(input,RPAREN,Follow._RPAREN_in_oexpr575); if (state.failed) return result;
			DebugLocation(158, 15);
			if (state.backtracking == 0)
			{

						result = new DepNode(op, iexpr5);
					
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("oexpr", 4);
			LeaveRule("oexpr", 4);
			LeaveRule_oexpr();
		}
		DebugLocation(161, 1);
		} finally { DebugExitRule(GrammarFileName, "oexpr"); }
		return result;

	}
	// $ANTLR end "oexpr"

	partial void EnterRule_iexpr();
	partial void LeaveRule_iexpr();
	// $ANTLR start "iexpr"
	// Dependency\\Parser\\ECX.g:164:1: iexpr returns [DepConstraint result] : c= CLASS (v= VER )? ;
	[GrammarRule("iexpr")]
	private DepConstraint iexpr()
	{
		EnterRule_iexpr();
		EnterRule("iexpr", 5);
		TraceIn("iexpr", 5);
		DepConstraint result = default(DepConstraint);


		IToken c = default(IToken);
		IToken v = default(IToken);

		 var con = new DepConstraint(); 
		try { DebugEnterRule(GrammarFileName, "iexpr");
		DebugLocation(164, 1);
		try
		{
			// Dependency\\Parser\\ECX.g:166:2: (c= CLASS (v= VER )? )
			DebugEnterAlt(1);
			// Dependency\\Parser\\ECX.g:166:4: c= CLASS (v= VER )?
			{
			DebugLocation(166, 5);
			c=(IToken)Match(input,CLASS,Follow._CLASS_in_iexpr600); if (state.failed) return result;
			DebugLocation(166, 12);
			// Dependency\\Parser\\ECX.g:166:12: (v= VER )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==VER))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// Dependency\\Parser\\ECX.g:166:14: v= VER
				{
				DebugLocation(166, 15);
				v=(IToken)Match(input,VER,Follow._VER_in_iexpr606); if (state.failed) return result;
				DebugLocation(166, 20);
				if (state.backtracking == 0)
				{
					 con.SetVersion(v.Text); 
				}

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(166, 51);
			if (state.backtracking == 0)
			{

						con.Name = c.Text;
						result = con;
					
			}

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("iexpr", 5);
			LeaveRule("iexpr", 5);
			LeaveRule_iexpr();
		}
		DebugLocation(170, 1);
		} finally { DebugExitRule(GrammarFileName, "iexpr"); }
		return result;

	}
	// $ANTLR end "iexpr"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _zexpr_in_expr416 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_expr418 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_cexpr441 = new BitSet(new ulong[]{0x2300010UL});
		public static readonly BitSet _AND_in_cexpr444 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _OR_in_cexpr450 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _XOR_in_cexpr456 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _OPT_in_cexpr462 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _zexpr_in_cexpr468 = new BitSet(new ulong[]{0x408000UL});
		public static readonly BitSet _RPAREN_in_cexpr474 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _cexpr_in_zexpr492 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _oexpr_in_zexpr498 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_oexpr521 = new BitSet(new ulong[]{0xF4380UL});
		public static readonly BitSet _EQ_in_oexpr524 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _NEQ_in_oexpr530 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _LTE_in_oexpr536 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _LT_in_oexpr542 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _GTE_in_oexpr549 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _GT_in_oexpr555 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _LD_in_oexpr561 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _NL_in_oexpr567 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _iexpr_in_oexpr573 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _RPAREN_in_oexpr575 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CLASS_in_iexpr600 = new BitSet(new ulong[]{0x800002UL});
		public static readonly BitSet _VER_in_iexpr606 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  ECX.Core.Dependency.Parser 
